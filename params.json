{"name":"Thread-worker","tagline":"PHP multi-thread worker message based library","body":"drealecs/thread-worker\r\n=============\r\n\r\nPHP multi-thread-worker message/event library\r\n[![Build Status](https://secure.travis-ci.org/drealecs/thread-worker.png?branch=master)](http://travis-ci.org/drealecs/thread-worker)\r\n\r\nIntroduction\r\n------------\r\n\r\nThread-worker is a library that allows execution of tasks in parallel by multiple PHP processes\r\non the same computer or on different computers.\r\n\r\nThe library has a lot of concepts borrowed from other languages.\r\n\r\n\r\n\r\nConcepts\r\n--------\r\n\r\n - **Task** represents a function that should be executed asynchronously.\r\n\r\n - **Queue** is a queue of tasks. Tasks can be put into queue by a process and taken out for execution by another process.\r\n\r\n - **Executor** is an wrapper over a queue. It can be passed to running task so that those tasks can spawn more tasks.\r\n\r\n - **TaskResult** or **TaskException** are the result of a **Task**.\r\n\r\n**Task**, **TaskResult** and **TaskException** are the entities that are being serialized as \"messages\" and write to/read from the queue.\r\n\r\nAPI\r\n---\r\n\r\n### Task\r\n\r\nA code that will be executed remotely cannot share variables or context with the calling code. When defining a function\r\nthat can be executed asynchronously it must be created as a Task by extending \\ThreadWorker\\Task and implementing method `run()`:\r\n``` php\r\nclass AddTask extends ThreadWorker\\Task\r\n{\r\n    public function run($a, $b)\r\n    {\r\n        returns $a + $b;\r\n    }\r\n}\r\n```\r\nand after that, the task can be used in this way:\r\n``` php\r\n$task = new AddTask(3, 5);\r\n$result = $task();\r\n```\r\nand this will make `$result` equals 8.\r\n\r\nJust like a function, a task can return a value or not.\r\n\r\nOf course, the example above execute a task locally, synchronously. To execute it asynchronously we will need a Queue and an Executor.\r\n\r\n### Queue\r\n\r\nTo synchronize working tasks a queue concept is being used.\r\n\r\nThere is a queue, someone puts a task in the queue and there are workers that take it and run it.\r\n\r\n\r\nInterface of a task queue:\r\n\r\n - public function queue($task, $captureResult); - called to queue a task for execution. There are Tasks that don't return a result and Tasks that returns a result.\r\nA task that does not returns a result is usually preferable because the calling code can do other things and get out of scope or even finish execution.\r\nTo accomplish this `$captureResult` must be `false` in which case the methods does not returns anything.\r\nIf we need a execute multiple task remotely and join their result we might need to pass second parameter as `true` and `queue()` method will return a task\r\nidentifier that can be used later to query and retrieve the task result.\r\n\r\n - public function start() - called by the script that can execute a task. This is a blocking method and it blocks until there is a task in the queue.\r\nIt returns a RemoteTask which is a container for the Task and it's TaskResult.\r\n\r\n - public function end($remoteTask) - called by the script that executed the task. It marks the task a being finished and it task is one that returns\r\na response, it stores the TaskResult.\r\n\r\n - public function getResult($taskId) - usually called by the script that queued the task for execution. It can be called only one time and is blocking\r\nuntil the task finished to execute.\r\n\r\n - public function isQueued|isRunning|isFinished($taskId) - methods that can query the state of a task.\r\n\r\n - public function getQueueSize() and getRunningSize() - methods that can query the queue for it's current workflow capacity.\r\n\r\nCurrently there is only one implementation of Queue: \\ThreadWorker\\RedisQueue and there are plans for: AMQPQueue, MySQLQueue\r\n\r\n\r\n### Executor\r\n\r\nExecutor wraps a queue and provide a simpler interface to queue task and work on tasks and get task results.\r\n\r\nThere is a QueueExecutor that has 2 methods:\r\n\r\n - void execute(Task $task) - adds the task to the queue\r\n - QueuedTask submit(Task $task) - adds the task to the queue and returns a QueuedTask instance that can be used to query task status and retrieve the task result.\r\n\r\nLet's look at an example:\r\n\r\n``` php\r\n$queue = new ThreadWorker\\RedisQueue('example');\r\n$executor = new ThreadWorker\\QueueExecutor($queue);\r\n\r\n$task = new AddTask(3, 5);\r\n$queuedTask = $executor->submit($task);\r\n$result = $queuedTask->getResult()->getValue();\r\n```\r\n\r\nQueueExecutor is extended into RemoteExecutor that does the asynchronous running of the tasks.\r\nWorker's code would look like this:\r\n\r\n``` php\r\n$queue = new ThreadWorker\\RedisQueue('example');\r\n$worker = new ThreadWorker\\RemoteExecutor($queue);\r\n\r\n$worker->work();\r\n```\r\n\r\nAn instance of RemoteExecutor is passed as an extra parameter to the `run()` method of the task and can be use to queue more tasks.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}